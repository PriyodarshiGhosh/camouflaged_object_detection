# -*- coding: utf-8 -*-
"""OBJECT_DETECTION.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iAhPMzm9HZ-h0SdCmmrXPM1_zDQq2DS7
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg')

# Convert the image to the YCbCr color space
img_ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

# Define the color range for the object of interest in the YCbCr color space
lower_ycbcr = np.array([0, 133, 77], dtype=np.uint8)  # Lower bound for YCbCr values (Y, Cb, Cr)
upper_ycbcr = np.array([255, 173, 127], dtype=np.uint8)  # Upper bound for YCbCr values (Y, Cb, Cr)

# Create a mask that only selects pixels within the defined color range in the YCbCr color space
mask_ycbcr = cv2.inRange(img_ycbcr, lower_ycbcr, upper_ycbcr)

# Convert the image to the RGB color space
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Define the color range for the object of interest in the RGB color space
lower_rgb = np.array([0, 0, 200], dtype=np.uint8)  # Lower bound for RGB values (R, G, B)
upper_rgb = np.array([50, 50, 255], dtype=np.uint8)  # Upper bound for RGB values (R, G, B)

# Create a mask that only selects pixels within the defined color range in the RGB color space
mask_rgb = cv2.inRange(img_rgb, lower_rgb, upper_rgb)

# Combine the masks to get the final mask for the object of interest
mask = cv2.bitwise_or(mask_ycbcr, mask_rgb)

# Apply the mask to the original image to extract the object of interest
res = cv2.bitwise_and(img, img, mask=mask)

# Display the original image and the extracted object side by side
cv2_imshow(img)
cv2_imshow(res)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg')

# Convert the image to the YCbCr color space
img_ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

# Define the color range for the object of interest in the YCbCr color space
lower_ycbcr = np.array([0, 133, 77], dtype=np.uint8)  # Lower bound for YCbCr values (Y, Cb, Cr)
upper_ycbcr = np.array([255, 255, 255], dtype=np.uint8)  # Upper bound for YCbCr values (Y, Cb, Cr)

# Create a mask that only selects pixels within the defined color range in the YCbCr color space
mask_ycbcr = cv2.inRange(img_ycbcr, lower_ycbcr, upper_ycbcr)

# Apply edge detection using the Canny algorithm to the mask
edges = cv2.Canny(mask_ycbcr, 100, 200)

# Convert the image to the RGB color space
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Define the color range for the object of interest in the RGB color space
lower_rgb = np.array([0, 0, 0], dtype=np.uint8)  # Lower bound for RGB values (R, G, B)
upper_rgb = np.array([255, 255, 255], dtype=np.uint8)  # Upper bound for RGB values (R, G, B)

# Create a mask that only selects pixels within the defined color range in the RGB color space
mask_rgb = cv2.inRange(img_rgb, lower_rgb, upper_rgb)

# Combine the masks to get the final mask for the object of interest
mask = cv2.bitwise_or(mask_ycbcr, mask_rgb)

# Apply the mask to the edges image to extract the object of interest
edges_masked = cv2.bitwise_and(edges, edges, mask=mask)

# Apply the mask to the original image to extract the object of interest
res = cv2.bitwise_and(img, img, mask=mask)

# Display the original image, edges image, and the extracted object side by side
cv2_imshow(img)
cv2_imshow(edges_masked)
cv2_imshow(res)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr color space
image = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 138, 65])
upper_y = np.array([255, 170, 127])

# Create a mask using the color thresholds
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)

# Define color thresholds for RGB color space
lower_r = np.array([150, 0, 0])
upper_r = np.array([255, 70, 70])

# Create a mask using the color thresholds
mask_r = cv2.inRange(image, lower_r, upper_r)

# Combine the masks
mask = cv2.bitwise_or(mask_y, mask_r)

# Apply the mask to the original image
result = cv2.bitwise_and(image, image, mask=mask)

# Show the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr color space
image = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Create a mask using the color thresholds
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask_y, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour (which should be the object of interest)
largest_contour = max(contours, key=cv2.contourArea)

# Create a mask for the largest contour
mask = np.zeros_like(mask_y)
cv2.drawContours(mask, [largest_contour], 0, 255, -1)

# Apply the mask to the original image
result = cv2.bitwise_and(image, image, mask=mask)

# Show the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr color space
image = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Create a binary mask using adaptive thresholding
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (5, 5), 0)
mask_y = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 21, 2)

# Apply morphological operations to remove noise and fill in gaps
kernel = np.ones((5, 5), np.uint8)
mask_y = cv2.erode(mask_y, kernel, iterations=1)
mask_y = cv2.dilate(mask_y, kernel, iterations=1)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask_y, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour (which should be the object of interest)
largest_contour = max(contours, key=cv2.contourArea)

# Create a new mask for the largest contour
mask = np.zeros_like(mask_y)
cv2.drawContours(mask, [largest_contour], 0, 255, -1)

# Apply the mask to the original image
result = cv2.bitwise_and(image, image, mask=mask)

# Show the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr and RGB color spaces
image = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)
rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Define color thresholds for RGB color space
lower_r = np.array([50, 50, 200])
upper_r = np.array([200, 200, 255])

# Create binary masks for each color space
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)
mask_r = cv2.inRange(rgb, lower_r, upper_r)

# Combine the binary masks using bitwise AND
mask = cv2.bitwise_and(mask_y, mask_r)

# Apply morphological operations to remove noise and fill in gaps
kernel = np.ones((5, 5), np.uint8)
mask = cv2.erode(mask, kernel, iterations=1)
mask = cv2.dilate(mask, kernel, iterations=1)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour (which should be the object of interest)
largest_contour = max(contours, key=cv2.contourArea)

# Create a new mask for the largest contour
mask = np.zeros_like(mask)
cv2.drawContours(mask, [largest_contour], 0, 255, -1)

# Apply the mask to the original image
result = cv2.bitwise_and(image, image, mask=mask)

# Show the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr and RGB color spaces
image = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)
rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Define color thresholds for RGB color space
lower_r = np.array([50, 50, 200])
upper_r = np.array([200, 200, 255])

# Create binary masks for each color space
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)
mask_r = cv2.inRange(rgb, lower_r, upper_r)

# Combine the binary masks using bitwise AND
mask = cv2.bitwise_and(mask_y, mask_r)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour (which should be the object of interest)
largest_contour = max(contours, key=cv2.contourArea)

# Create a new mask for the largest contour
mask = np.zeros_like(mask)
cv2.drawContours(mask, [largest_contour], 0, 255, -1)

# Apply the mask to the original image
result = cv2.bitwise_and(image, image, mask=mask)

# Show the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr color space
image = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Create binary mask for YCbCr color space
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask_y, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Check if contours were found
if len(contours) == 0:
    print("No contours found in image.")
else:
    # Find the largest contour (which should be the object of interest)
    largest_contour = max(contours, key=cv2.contourArea)

    # Create a new mask for the largest contour
    mask = np.zeros_like(mask_y)
    cv2.drawContours(mask, [largest_contour], 0, 255, -1)

    # Apply the mask to the original image
    result = cv2.bitwise_and(image, image, mask=mask)

    # Show the result
    cv2_imshow(result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr color space
image = cv2.imread("/content/COD10K-CAM-1-Aquatic-7-Flounder-250.jpg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Create binary mask for YCbCr color space
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask_y, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Check if contours were found
if len(contours) == 0:
    print("No contours found in image.")
else:
    # Find the largest contour (which should be the object of interest)
    largest_contour = max(contours, key=cv2.contourArea)

    # Create a new mask for the largest contour
    mask = np.zeros_like(mask_y)
    cv2.drawContours(mask, [largest_contour], 0, 255, -1)

    # Apply Canny edge detection to the largest contour
    edges = cv2.Canny(mask, 100, 200)

    # Apply the mask and edges to the original image
    result = cv2.bitwise_and(image, image, mask=mask)
    result = cv2.bitwise_or(result, cv2.cvtColor(edges, cv2.COLOR_GRAY2BGR))

    # Show the result
    cv2_imshow(result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr color space
image = cv2.imread("/content/COD10K-CAM-2-Terrestrial-22-Bug-1260.jpg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Create binary mask for YCbCr color space
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)

# Apply Gaussian smoothing to the mask
kernel = cv2.getGaussianKernel(ksize=8, sigma=0)
mask_y = cv2.filter2D(mask_y, -1, kernel)
mask_y = cv2.GaussianBlur(mask_y, (5, 5), 0)

# Apply morphological operations to the mask
kernel = np.ones((5, 5), np.uint8)
mask_y = cv2.morphologyEx(mask_y, cv2.MORPH_OPEN, kernel)
mask_y = cv2.morphologyEx(mask_y, cv2.MORPH_CLOSE, kernel)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask_y, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Check if contours were found
if len(contours) == 0:
    print("No contours found in image.")
else:
    # Find the largest contour (which should be the object of interest)
    largest_contour = max(contours, key=cv2.contourArea)

    # Create a new mask for the largest contour
    mask = np.zeros_like(mask_y)
    cv2.drawContours(mask, [largest_contour], 0, 255, -1)

    # Apply the mask to the original image
    result = cv2.bitwise_and(image, image, mask=mask)

    # Apply Canny edge detection to the contour
    edges = cv2.Canny(mask, 100, 200)

    # Show the result
    cv2_imshow(result)
    cv2_imshow(edges)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image and convert to YCbCr color space
image = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")
ycbcr = cv2.cvtColor(image, cv2.COLOR_BGR2YCrCb)

# Define color thresholds for YCbCr color space
lower_y = np.array([0, 133, 77])
upper_y = np.array([255, 173, 127])

# Create binary mask for YCbCr color space
mask_y = cv2.inRange(ycbcr, lower_y, upper_y)

# Apply Gaussian smoothing to the mask with different kernel sizes and sigma values
kernels = [(3, 0), (5, 0), (7, 0), (3, 1), (5, 1), (7, 1)]
for kernel_size, sigma in kernels:
    kernel = cv2.getGaussianKernel(ksize=kernel_size, sigma=sigma)
    mask = cv2.filter2D(mask_y, -1, kernel)
    mask = cv2.GaussianBlur(mask, (kernel_size, kernel_size), sigma)

    # Find contours in the mask
    contours, hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Check if contours were found
    if len(contours) == 0:
        print(f"No contours found with kernel size {kernel_size} and sigma {sigma}.")
    else:
        # Find the largest contour (which should be the object of interest)
        largest_contour = max(contours, key=cv2.contourArea)

        # Create a new mask for the largest contour
        contour_mask = np.zeros_like(mask)
        cv2.drawContours(contour_mask, [largest_contour], 0, 255, -1)

        # Apply the mask to the original image
        result = cv2.bitwise_and(image, image, mask=contour_mask)

        # Show the result
        cv2_imshow(result)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread("/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg")

# Convert to YCbCr color space
ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

# Convert to RGB color space
rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Set YCbCr color thresholds for object detection
ycbcr_lower = np.array([0, 133, 77], dtype=np.uint8)
ycbcr_upper = np.array([255, 173, 127], dtype=np.uint8)

# Set RGB color thresholds for object detection
rgb_lower = np.array([200, 0, 0], dtype=np.uint8)
rgb_upper = np.array([255, 150, 150], dtype=np.uint8)

# Create a mask for the YCbCr threshold
ycbcr_mask = cv2.inRange(ycbcr, ycbcr_lower, ycbcr_upper)

# Create a mask for the RGB threshold
rgb_mask = cv2.inRange(rgb, rgb_lower, rgb_upper)

# Combine the masks
mask = cv2.bitwise_or(ycbcr_mask, rgb_mask)

# Apply morphological operations to the mask to remove noise
kernel = np.ones((5, 5), np.uint8)
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

# Find contours in the mask
contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Iterate through the contours and draw bounding boxes around the objects
for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)
    cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)

# Display the image with the bounding boxes
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread("/content/COD10K-CAM-1-Aquatic-7-Flounder-250.jpg")

# Convert the image to YCbCr color space
ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)

# Define the color thresholds
lower_color = np.array([0, 133, 77])
upper_color = np.array([255, 173, 127])

# Apply the color threshold
mask = cv2.inRange(ycbcr, lower_color, upper_color)

# Find contours in the binary image
contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest bounding box
largest_box = None
largest_area = 0
for contour in contours:
    # Get the bounding box of the contour
    x, y, w, h = cv2.boundingRect(contour)
    area = w * h

    # Keep track of the largest bounding box
    if area > largest_area:
        largest_area = area
        largest_box = (x, y, w, h)

# Draw the largest bounding box
if largest_box is not None:
    x, y, w, h = largest_box
    cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)

# Display the image
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53.jpeg')

# Convert the image to YCbCr color space
ycbcr = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)

# Define the color thresholds
lower_color = np.array([0, 133, 77])
upper_color = np.array([255, 173, 127])

# Apply the color threshold
mask = cv2.inRange(ycbcr, lower_color, upper_color)

# Perform histogram equalization to enhance the contrast
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
equalized = cv2.equalizeHist(gray)

# Perform edge detection
edges = cv2.Canny(equalized, 50, 150)

# Perform morphological opening to remove noise
kernel = np.ones((5, 5), np.uint8)
opening = cv2.morphologyEx(edges, cv2.MORPH_OPEN, kernel)

# Find contours in the binary image
contours, _ = cv2.findContours(opening, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest bounding box
largest_box = None
largest_area = 0
for contour in contours:
    # Get the bounding box of the contour
    x, y, w, h = cv2.boundingRect(contour)
    area = w * h

    # Keep track of the largest bounding box
    if area > largest_area:
        largest_area = area
        largest_box = (x, y, w, h)

# Draw the largest bounding box
if largest_box is not None:
    x, y, w, h = largest_box
    cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)

# Display the image
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread('/content/COD10K-CAM-1-Aquatic-7-Flounder-250.jpg')

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply thresholding
_, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)

# Find contours in the image
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Sort the contours by their areas in descending order
contours = sorted(contours, key=cv2.contourArea, reverse=True)[:4]

# Draw the bounding boxes around the contours
for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)
    cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)

# Display the image
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (2).jpeg')


# Convert to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Threshold the image
_, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Find the contours
contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Sort the contours by area
contours = sorted(contours, key=cv2.contourArea, reverse=True)[:4]

# Create a blank mask
mask = np.zeros_like(gray)

# Draw the contours on the mask
for contour in contours:
    cv2.drawContours(mask, [contour], 0, 255, -1)

# Apply a bitwise-and operation to the original image using the mask
result = cv2.bitwise_and(img, img,mask=mask)

# Show the result
cv2_imshow(result)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load the image
img = cv2.imread('/content/COD10K-CAM-1-Aquatic-7-Flounder-250.jpg')


# Convert to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Threshold the image
_, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Find the contours
contours, _ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Sort the contours by area
contours = sorted(contours, key=cv2.contourArea, reverse=True)[:4]

# Create a blank mask
mask = np.zeros_like(gray)
for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)
    cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)

# Draw the contours on the mask
# for contour in contours:
#     cv2.drawContours(mask, [contour], 0, 255, -1)

# # Apply a bitwise-and operation to the original image using the mask
result = cv2.bitwise_and(img, img, mask=mask)

# Show the result
cv2_imshow(img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow
# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (3).jpeg')

# Convert image to HSI color model
hsi_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS_FULL)

# Convert image to HSV color model
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Convert image to HSL color model
hsl_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS)

# Display images
cv2_imshow(img)
cv2_imshow(hsi_img)
cv2_imshow(hsv_img)
cv2_imshow(hsl_img)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (3).jpeg')

# Convert image to YIQ color model
yiq_img = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)
yiq_img[:,:,0], yiq_img[:,:,1], yiq_img[:,:,2] = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb))
yiq_img = yiq_img.astype(np.float32) / 255.0
yiq_img[:,:,1] -= 0.5
yiq_img[:,:,2] -= 0.5
yiq_img = np.dot(yiq_img, np.array([[0.299, 0.587, 0.114], [0.596, -0.274, -0.322], [0.211, -0.523, 0.312]]).T)
yiq_img = (yiq_img * 255).clip(0, 255).astype(np.uint8)


# Convert image to YUV color model
yuv_img = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)

# Convert image to YCbCr color model
ycbcr_img = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

# Display images
cv2_imshow(img)
cv2_imshow(yiq_img.astype(np.uint8))
cv2_imshow(yuv_img)
cv2_imshow(ycbcr_img)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np

# Load the image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (3).jpeg')

# Convert the image from BGR to RGB format
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Convert the image from RGB to CIELAB color space
lab_img = cv2.cvtColor(img, cv2.COLOR_RGB2LAB)

# Display the CIELAB image
cv2_imshow(lab_img)

# Wait for a key press to close the window
cv2.waitKey(0)

# Close all windows
cv2.destroyAllWindows()

import cv2
import numpy as np

# Load image
img = cv2.imread('/content/COD10K-CAM-1-Aquatic-9-GhostPipefish-318.jpg')

# Convert image to HSI color model
hsi_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS_FULL)

# Define color range for object of interest
lower_color = np.array([0, 50, 50])
upper_color = np.array([180, 255, 255])

# Create a mask of the object of interest
mask = cv2.inRange(hsi_img, lower_color, upper_color)

# Apply morphological transformations to the mask
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Draw contours on original image
cv2.drawContours(img, contours, -1, (0, 255, 0), 3)

# Display images
cv2_imshow(img)
cv2_imshow(mask)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (3).jpeg')

# Convert image to HSI color model
hsi_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS_FULL)

# Define color range for object of interest
lower_color = np.array([0, 50, 50])
upper_color = np.array([180, 255, 255])

# Create a mask of the object of interest
mask = cv2.inRange(hsi_img, lower_color, upper_color)

# Apply erosion and dilation operations to the mask
kernel = np.ones((5,5),np.uint8)
mask = cv2.erode(mask,kernel,iterations = 1)
mask = cv2.dilate(mask,kernel,iterations = 1)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour
largest_contour = max(contours, key=cv2.contourArea)

# Create a new mask containing only the region inside the largest contour
mask_inside = np.zeros_like(mask)
cv2.drawContours(mask_inside, [largest_contour], -1, (255, 255, 255), -1)

# Apply the new mask to the original image to extract the object of interest
object_of_interest = cv2.bitwise_and(img, img, mask=mask_inside)

# Create a rectangular mask to select only the region of interest
x,y,w,h = cv2.boundingRect(largest_contour)
roi_mask = np.zeros_like(mask)
roi_mask[y:y+h, x:x+w] = 255

# Crop the image to the region of interest
object_of_interest = cv2.bitwise_and(object_of_interest, object_of_interest, mask=roi_mask)

# Display images
cv2_imshow(img)
cv2_imshow(object_of_interest)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (3).jpeg')

# Convert image to HSV color model
hsi_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Define color range for object of interest
lower_color = np.array([0, 50, 50])
upper_color = np.array([180, 255, 255])

# Create a mask of the object of interest
mask = cv2.inRange(hsi_img, lower_color, upper_color)

# Apply erosion and dilation operations to the mask
kernel = np.ones((5,5),np.uint8)
mask = cv2.erode(mask,kernel,iterations = 1)
mask = cv2.dilate(mask,kernel,iterations = 1)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour
largest_contour = max(contours, key=cv2.contourArea)

# Create a new mask containing only the region inside the largest contour
mask_inside = np.zeros_like(mask)
cv2.drawContours(mask_inside, [largest_contour], -1, (255, 255, 255), -1)

# Apply the new mask to the original image to extract the object of interest
object_of_interest = cv2.bitwise_and(img, img, mask=mask_inside)

# Create a rectangular mask to select only the region of interest
x,y,w,h = cv2.boundingRect(largest_contour)
roi_mask = np.zeros_like(mask)
roi_mask[y:y+h, x:x+w] = 255

# Crop the image to the region of interest
object_of_interest = cv2.bitwise_and(object_of_interest, object_of_interest, mask=roi_mask)

# Display images
cv2_imshow(img)
cv2_imshow(object_of_interest)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (3).jpeg')

# Convert image to HSV color model
hsi_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS)

# Define color range for object of interest
lower_color = np.array([0, 50, 50])
upper_color = np.array([180, 255, 255])

# Create a mask of the object of interest
mask = cv2.inRange(hsi_img, lower_color, upper_color)

# Apply erosion and dilation operations to the mask
kernel = np.ones((5,5),np.uint8)
mask = cv2.erode(mask,kernel,iterations = 1)
mask = cv2.dilate(mask,kernel,iterations = 1)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour
largest_contour = max(contours, key=cv2.contourArea)

# Create a new mask containing only the region inside the largest contour
mask_inside = np.zeros_like(mask)
cv2.drawContours(mask_inside, [largest_contour], -1, (255, 255, 255), -1)

# Apply the new mask to the original image to extract the object of interest
object_of_interest = cv2.bitwise_and(img, img, mask=mask_inside)

# Create a rectangular mask to select only the region of interest
x,y,w,h = cv2.boundingRect(largest_contour)
roi_mask = np.zeros_like(mask)
roi_mask[y:y+h, x:x+w] = 255

# Crop the image to the region of interest
object_of_interest = cv2.bitwise_and(object_of_interest, object_of_interest, mask=roi_mask)

# Display images
cv2_imshow(img)
cv2_imshow(object_of_interest)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (3).jpeg')

# Convert image to YIQ color model
yiq_img = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)

# Define color range for object of interest
lower_color = np.array([0, 135, 85])
upper_color = np.array([255, 180, 135])

# Create a mask of the object of interest
mask = cv2.inRange(yiq_img, lower_color, upper_color)

# Apply erosion and dilation operations to the mask
kernel = np.ones((5,5),np.uint8)
mask = cv2.erode(mask,kernel,iterations = 1)
mask = cv2.dilate(mask,kernel,iterations = 1)

# Find contours in the mask
contours, hierarchy = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

# Find the largest contour
largest_contour = max(contours, key=cv2.contourArea)

# Create a new mask containing only the region inside the largest contour
mask_inside = np.zeros_like(mask)
cv2.drawContours(mask_inside, [largest_contour], -1, (255, 255, 255), -1)

# Apply the new mask to the original image to extract the object of interest
object_of_interest = cv2.bitwise_and(img, img, mask=mask_inside)

# Create a rectangular mask to select only the region of interest
x,y,w,h = cv2.boundingRect(largest_contour)
roi_mask = np.zeros_like(mask)
roi_mask[y:y+h, x:x+w] = 255

# Crop the image to the region of interest
object_of_interest = cv2.bitwise_and(object_of_interest, object_of_interest, mask=roi_mask)

# Display images
cv2_imshow(img)
cv2_imshow(object_of_interest)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (4).jpeg')

# Convert image to HSV color model
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Define lower and upper bounds for the object color in HSV color space
lower_color = np.array([0, 50, 100])
upper_color = np.array([180, 255, 255])

# Create a binary mask where pixels within the specified range are marked with 1 and the rest with 0
mask = cv2.inRange(hsv_img,lower_color, upper_color)

# Apply the mask to the original image to extract the object
object_img = cv2.bitwise_and(img, img, mask=mask)

# Display the object image
cv2_imshow(object_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (4).jpeg')

# Convert image to HSV color model
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS)

# Define lower and upper bounds for the object color in HSV color space
lower_color = np.array([0, 50, 100])
upper_color = np.array([180, 255, 255])

# Create a binary mask where pixels within the specified range are marked with 1 and the rest with 0
mask = cv2.inRange(hsv_img,lower_color, upper_color)

# Apply the mask to the original image to extract the object
object_img = cv2.bitwise_and(img, img, mask=mask)

# Display the object image
cv2_imshow(object_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (4).jpeg')

# Convert image to HSV color model
hsv_img = cv2.cvtColor(img,  cv2.COLOR_BGR2HLS_FULL)

# Define lower and upper bounds for the object color in HSV color space
lower_color = np.array([0, 0, 100])
upper_color = np.array([180, 255, 255])

# Create a binary mask where pixels within the specified range are marked with 1 and the rest with 0
mask = cv2.inRange(hsv_img,lower_color, upper_color)

# Apply the mask to the original image to extract the object
object_img = cv2.bitwise_and(img, img, mask=mask)

# Display the object image
cv2_imshow(object_img)
cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (4).jpeg')

# Convert image to HSV color space
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Define range of colors in HSV
hue_range = [20, 40]  # Range of hue values (in degrees)
sat_range = [100, 255]  # Range of saturation values
val_range = [100, 255]  # Range of value/brightness values

# Define lower and upper bounds based on desired range
lower_color = np.array([0, sat_range[0], val_range[0]])
upper_color = np.array([180, sat_range[1], val_range[1]])

# Create a mask that only includes pixels within the specified HSV range
mask = cv2.inRange(hsv_img, lower_color, upper_color)

# Use adaptive thresholding to create a binary image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Apply the mask to the binary image to extract the region of interest
roi = cv2.bitwise_and(thresh, thresh, mask=mask)

# Display the original image, the binary image, and the extracted region of interest
cv2_imshow(img)
cv2_imshow(thresh)
cv2_imshow(roi)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (4).jpeg')

# Convert image to HSV color space
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS_FULL)

# Define range of colors in HSV
hue_range = [20, 40]  # Range of hue values (in degrees)
sat_range = [100, 255]  # Range of saturation values
val_range = [100, 255]  # Range of value/brightness values

# Define lower and upper bounds based on desired range
lower_color = np.array([0, sat_range[0], val_range[0]])
upper_color = np.array([180, sat_range[1], val_range[1]])

# Create a mask that only includes pixels within the specified HSV range
mask = cv2.inRange(hsv_img, lower_color, upper_color)

# Use adaptive thresholding to create a binary image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Apply the mask to the binary image to extract the region of interest
roi = cv2.bitwise_and(thresh, thresh, mask=mask)

# Display the original image, the binary image, and the extracted region of interest
cv2_imshow(img)
cv2_imshow(thresh)
cv2_imshow(roi)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/COD10K-CAM-1-Aquatic-6-Fish-135.jpg')

# Convert image to HSV color space
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS_FULL)

# Define range of colors in HSV
hue_range = [20, 40]  # Range of hue values (in degrees)
sat_range = [100, 255]  # Range of saturation values
val_range = [100, 255]  # Range of value/brightness values

# Define lower and upper bounds based on desired range
lower_color = np.array([0, sat_range[0], val_range[0]])
upper_color = np.array([180, sat_range[1], val_range[1]])

# Create a mask that only includes pixels within the specified HSV range
mask = cv2.inRange(hsv_img, lower_color, upper_color)

# Use adaptive thresholding to create a binary image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Apply the mask to the binary image to extract the region of interest
roi = cv2.bitwise_and(thresh, thresh, mask=mask)

# Display the original image, the binary image, and the extracted region of interest
cv2_imshow(img)
cv2_imshow(thresh)
cv2_imshow(roi)
cv2_imshow(mask)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (4).jpeg')

# Convert image to HSV color space
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HLS)

# Define range of colors in HSV
hue_range = [20, 40]  # Range of hue values (in degrees)
sat_range = [100, 255]  # Range of saturation values
val_range = [100, 255]  # Range of value/brightness values

# Define lower and upper bounds based on desired range
lower_color = np.array([0, sat_range[0], val_range[0]])
upper_color = np.array([180, sat_range[1], val_range[1]])

# Create a mask that only includes pixels within the specified HSV range
mask = cv2.inRange(hsv_img, lower_color, upper_color)

# Use adaptive thresholding to create a binary image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Apply the mask to the binary image to extract the region of interest
roi = cv2.bitwise_and(thresh, thresh, mask=mask)

# Display the original image, the binary image, and the extracted region of interest
cv2_imshow(img)
cv2_imshow(thresh)
cv2_imshow(roi)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (4).jpeg')

# Convert image to YCbCr color space
ycbcr_img = cv2.cvtColor(img, cv2.COLOR_BGR2YCR_CB)

# Define range of colors in YCbCr
cb_range = [30, 130]  # Range of Cb values
cr_range = [255, 170]  # Range of Cr values

# Create a mask that only includes pixels within the specified YCbCr range
lower_color = np.array([0, cb_range[0], cr_range[0]])
upper_color = np.array([255, cb_range[1], cr_range[1]])
mask = cv2.inRange(ycbcr_img, lower_color, upper_color)

# Use adaptive thresholding to create a binary image
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)

# Apply the mask to the binary image to extract the region of interest
roi = cv2.bitwise_and(thresh, thresh, mask=mask)

# Display the original image, the binary image, and the extracted region of interest
cv2_imshow(img)
cv2_imshow(thresh)
cv2_imshow(roi)

cv2.waitKey(0)
cv2.destroyAllWindows()

import cv2
import numpy as np
from skimage.feature import greycomatrix, greycoprops
from google.colab.patches import cv2_imshow
# Load image
img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (5).jpeg')

# Convert image to HSV color space
hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

# Extract the Hue channel
hue = hsv_img[:,:,0]

# Threshold the Hue channel to segment the image into foreground and background regions
_, mask = cv2.threshold(hue, 30, 255, cv2.THRESH_BINARY)

# Extract the object using the mask
masked_img = cv2.bitwise_and(img, img, mask=mask)

# Compute the GLCM texture features on the foreground region
glcm = greycomatrix(hue, distances=[1], angles=[0], symmetric=True, normed=True)
contrast = greycoprops(glcm, 'contrast')[0][0]
dissimilarity = greycoprops(glcm, 'dissimilarity')[0][0]
threshold1 = 100
threshold2 = 10
# Classify the object as camouflaged or not based on the texture features
if contrast > threshold1 and dissimilarity < threshold2:
    print('The object is camouflaged')
    # Display the masked object
    cv2_imshow(masked_img)
    cv2.waitKey(0)
else:
    print('The object is not camouflaged')

import cv2
import numpy as np

# Load the background image
bg_img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (5).jpeg')

# Create a background mask using Canny edge detection
bg_gray = cv2.cvtColor(bg_img, cv2.COLOR_BGR2GRAY)
bg_edges = cv2.Canny(bg_gray, 100, 200)
bg_mask = cv2.threshold(bg_edges, 127, 255, cv2.THRESH_BINARY)[1]

# Load the foreground image
fg_img = cv2.imread('/content/WhatsApp Image 2023-02-14 at 09.41.53 (5).jpeg')

# Create a foreground mask using color and intensity information
fg_hsv = cv2.cvtColor(fg_img, cv2.COLOR_BGR2HSV)
fg_mask = cv2.inRange(fg_hsv, np.array([0, 0, 0]), np.array([255, 255, 100]))

# Combine the background and foreground masks
mask = cv2.bitwise_or(bg_mask, fg_mask)

# Apply the mask to the foreground image
masked_img = cv2.bitwise_and(fg_img, fg_img, mask=mask)

# Display the masked image
cv2_imshow(masked_img)
cv2.waitKey(0)